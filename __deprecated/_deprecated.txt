

! NOTE: TO BE DEPRECATED
subroutine run_old(max_loop, starting_pop)
    integer, intent(in) :: max_loop, starting_pop
    integer :: pop_size,       &
                step,           &
                index
    logical :: is_last_index, is_first_index
    type(Person), allocatable :: curr_pop(:), & ! Current population array
                                    next_pop(:)    ! Next population array
                                    

    call generate_population(curr_pop, starting_pop)
    allocate(next_pop(0))

    ! Initialize writer
    !   .txt file for Population
    call initialize_writer(pop_filename, pop_unit, pop_position)

    ! Main loop
    do step = 1, max_loop
        ! === Initialize variables ===
        pop_size = size(curr_pop)

        ! === Evaluate each individuals ===
        do index = 1, pop_size
            call step_age(curr_pop(index), next_pop, pop_size)

            ! Check death of individual
            if (curr_pop(index)%death_index == ALIVE) then
                ! NOTE: This could be faster
                ! TODO: Find a faster way to kill indivs.
                call array_insert(next_pop, curr_pop(index), 1)
            end if

            ! Index bound check
            if (index == 1) then
                is_first_index = .true.
                if (index == size(curr_pop)) then
                    is_last_index = .true.
                else
                    is_last_index = .false.
                end if
            else if (index == size(curr_pop)) then
                is_first_index = .false.
                is_last_index = .true.
            else
                is_first_index = .false.
                is_last_index = .false.
            end if

            ! call single_removal(is_dead, index, next_pop, is_first_index)

            ! call toggle_removal(is_dead, index, next_pop, &
            !                     is_first_index, is_last_index)
        end do
        ! Recording population
        write(pop_unit, pop_format) pop_size

        deallocate(curr_pop)
        call move_alloc(next_pop, curr_pop)
        allocate(next_pop(0))
    end do

    ! Close writers
    close(pop_unit)

    ! Deallocate arrays. Just to be sure
    deallocate(next_pop, curr_pop)
end subroutine run_old


! NOTE: TO BE DEPRECATED
subroutine single_removal(is_dead, index, next_pop, &
                            is_started)
    implicit none
    type(Person), allocatable :: next_pop(:)
    logical, intent(in) :: is_dead, is_started
    integer, intent(in) :: index
    integer, save :: death_count = 0

    if (is_started) then
        print *, "***restart"
        death_count = 0
    end if

    if (.not.is_dead) then
        return
    else
        call array_remove(next_pop, index - death_count)
        death_count = death_count + 1
    end if
end subroutine single_removal


! NOTE: TO BE DEPRECATED
subroutine toggle_removal(is_dead, index, next_pop, &
                            is_started, is_last, offset)
    implicit none
    type(Person), intent(inout), allocatable :: next_pop(:)
    integer, intent(in) :: index
    integer, intent(inout) :: offset
    logical, intent(in) :: is_dead, is_last, is_started
    logical, save :: is_dead_prev
    integer, save :: last_d_count, &
                        death_count,  &
                        death_range(3) ! 1:lbound, 2:ubound, 3:toggle index

    if (is_started) then
        is_dead_prev = .false.
        death_range = [-1, -1, 1]
        death_count = 0
        last_d_count = 0
    end if

    if (is_dead) then
        death_count = death_count + 1
        if (.not.is_dead_prev) then
            death_range(death_range(3)) = index
            death_range(3) = 2
        end if
        if (is_last) then
            ! NOTE: This assumes that `index` is the last index.
            call array_remove_range(next_pop, &
                death_range(1) - last_d_count, &
                index - last_d_count)
        end if 
    else
        if (is_dead_prev) then
            death_range(death_range(3)) = index - 1
            death_range(3) = 1
            call array_remove_range(next_pop, &
                death_range(1) - last_d_count, &
                death_range(2) - last_d_count)
                last_d_count = death_count
        end if
    end if

    is_dead_prev = is_dead
    offset = last_d_count
end subroutine toggle_removal



! NOTE: From init.f08
module Model_old
  implicit none

  integer, parameter :: MODEL_L = 32              ! Genome/Bit-string length
  integer, parameter :: MODEL_T = 3               ! Mutation threshold
  integer, parameter :: MODEL_B = 1               ! Birth rate
  integer, parameter :: MODEL_M = 1               ! Mutation rate
  integer, parameter :: MODEL_R = 9               ! Reproduction age
  integer, parameter :: MODEL_R_MAX = 9           ! Maximum reproduction age
  integer, parameter :: MODEL_K = 20000           ! Carrying capacity
  integer, parameter :: MODEL_N0_D = 100          ! Default starting pop size
  integer, parameter :: MODEL_TIME_STEPS_D = 100  ! Default total time steps

  integer, private :: i   ! NOTE: Just a counter
  real :: MODEL_VERHULST_W(MODEL_L) = [(0.0, i = 1, MODEL_L)]

  private :: generateWeights   ! NOTE: Could be changed.
contains

  ! -------------------------------------------------------------------------- !
  ! FUNCTION: generateWeights
  !>  Generate `L` long array of Verhulst weights. The shape of the generated
  !!  values is that of a step function centered at `k`.
  ! -------------------------------------------------------------------------- !
  function generateWeights(L, k, isReversed) result(weights)
    implicit none
    integer, intent(in) :: k          ! Step function edge
    integer, intent(in) :: L          ! Length of the Verhulst weight array
    logical, intent(in) :: isReversed ! Invert the array values, e.g. 0 -> 1 
    real :: weights(L)
    real :: enable
    real :: disable

    if (isReversed) then
      enable = 1.0
      disable = 0.0
    else
      enable = 0.0
      disable = 1.0
    end if

    weights(1:k-1) = disable
    weights(k:L) = enable
  end function generateWeights
end module Model_old

